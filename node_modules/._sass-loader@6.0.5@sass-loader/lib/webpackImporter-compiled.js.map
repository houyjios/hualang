{"version":3,"sources":["../../sass-loader/lib/webpackImporter.js"],"names":[],"mappings":"AAAA;;AAEA;;;;;;;;AAQA;;;;;;;;AAQA,IAAM,OAAO,QAAQ,MAAR,CAAb;AACA,IAAM,QAAQ,QAAQ,cAAR,CAAd;AACA,IAAM,OAAO,QAAQ,aAAR,CAAb;AACA,IAAM,mBAAmB,QAAQ,oBAAR,CAAzB;;AAEA,IAAM,WAAW,QAAjB;;AAEA;;;;;;;;;;;AAWA,SAAS,eAAT,CAAyB,YAAzB,EAAuC,OAAvC,EAAgD,uBAAhD,EAAyE;AACrE,aAAS,cAAT,CAAwB,WAAxB,EAAqC;AACjC,eAAO,KAAK,OAAL;AACH;AACA,wBAAgB,OAAhB,GAA0B,YAA1B,GAAyC,WAFtC,CAAP;AAIH;;AAED,aAAS,cAAT,CAAwB,GAAxB,EAA6B,gBAA7B,EAA+C;AAC3C,eAAO,iBAAiB,MAAjB,KAA4B,CAA5B,GACH,QAAQ,MAAR,EADG,GAEH,QAAQ,GAAR,EAAa,iBAAiB,CAAjB,CAAb,EACK,IADL,CACU,wBAAgB;AAClB;AACA;AACA,oCAAwB,YAAxB;AACA,mBAAO;AACH;AACA,sBAAM,aAAa,OAAb,CAAqB,QAArB,EAA+B,EAA/B;AAFH,aAAP;AAIH,SATL,EASO;AAAA,mBAAM,eACL,GADK,EAEL,KAAK,gBAAL,CAFK,CAAN;AAAA,SATP,CAFJ;AAeH;;AAED,WAAO,UAAC,GAAD,EAAM,IAAN,EAAY,IAAZ,EAAqB;AACxB,uBACI,eAAe,IAAf,CADJ,EAEI,iBAAiB,MAAM,YAAN,CAAmB,GAAnB,CAAjB,CAFJ,EAGE;AAHF,SAIK,KAJL,CAIW;AAAA,mBAAO,EAAE,MAAM,GAAR,EAAP;AAAA,SAJX,EAKK,IALL,CAKU,IALV;AAMH,KAPD;AAQH;;AAED,OAAO,OAAP,GAAiB,eAAjB","file":"webpackImporter-compiled.js","sourcesContent":["\"use strict\";\n\n/**\n * @name PromisedResolve\n * @type {Function}\n * @param {string} dir\n * @param {string} request\n * @returns Promise\n */\n\n/**\n * @name Importer\n * @type {Function}\n * @param {string} url\n * @param {string} prev\n * @param {Function<Error, string>} done\n */\n\nconst path = require(\"path\");\nconst utils = require(\"loader-utils\");\nconst tail = require(\"lodash.tail\");\nconst importsToResolve = require(\"./importsToResolve\");\n\nconst matchCss = /\\.css$/;\n\n/**\n * Returns an importer that uses webpack's resolving algorithm.\n *\n * It's important that the returned function has the correct number of arguments\n * (based on whether the call is sync or async) because otherwise node-sass doesn't exit.\n *\n * @param {string} resourcePath\n * @param {PromisedResolve} resolve\n * @param {Function<string>} addNormalizedDependency\n * @returns {Importer}\n */\nfunction webpackImporter(resourcePath, resolve, addNormalizedDependency) {\n    function dirContextFrom(fileContext) {\n        return path.dirname(\n            // The first file is 'stdin' when we're using the data option\n            fileContext === \"stdin\" ? resourcePath : fileContext\n        );\n    }\n\n    function startResolving(dir, importsToResolve) {\n        return importsToResolve.length === 0 ?\n            Promise.reject() :\n            resolve(dir, importsToResolve[0])\n                .then(resolvedFile => {\n                    // Add the resolvedFilename as dependency. Although we're also using stats.includedFiles, this might come\n                    // in handy when an error occurs. In this case, we don't get stats.includedFiles from node-sass.\n                    addNormalizedDependency(resolvedFile);\n                    return {\n                        // By removing the CSS file extension, we trigger node-sass to include the CSS file instead of just linking it.\n                        file: resolvedFile.replace(matchCss, \"\")\n                    };\n                }, () => startResolving(\n                    dir,\n                    tail(importsToResolve)\n                ));\n    }\n\n    return (url, prev, done) => {\n        startResolving(\n            dirContextFrom(prev),\n            importsToResolve(utils.urlToRequest(url))\n        ) // Catch all resolving errors, return the original file and pass responsibility back to other custom importers\n            .catch(() => ({ file: url }))\n            .then(done);\n    };\n}\n\nmodule.exports = webpackImporter;\n"]}