{"version":3,"sources":["../../sass-loader/lib/proxyCustomImporters.js"],"names":[],"mappings":"AAAA;;AAEA;;;;;;;;;;;;;;;AAcA,SAAS,oBAAT,CAA8B,QAA9B,EAAwC,YAAxC,EAAsD;AAClD,WAAO,GAAG,MAAH,CAAU,QAAV,EAAoB,GAApB,CAAwB,UAAC,QAAD,EAAc;AACzC,eAAO,UAAU,GAAV,EAAe,IAAf,EAAqB,IAArB,EAA2B;AAC9B,mBAAO,SAAS,KAAT,CACH,IADG,EACG;AACN,kBAAM,IAAN,CAAW,SAAX,EACK,GADL,CACS,UAAC,GAAD,EAAM,CAAN;AAAA,uBAAY,MAAM,CAAN,IAAW,QAAQ,OAAnB,GAA6B,YAA7B,GAA4C,GAAxD;AAAA,aADT,CAFG,CAAP;AAKH,SAND;AAOH,KARM,CAAP;AASH;;AAED,OAAO,OAAP,GAAiB,oBAAjB","file":"proxyCustomImporters-compiled.js","sourcesContent":["\"use strict\";\n\n/**\n * Creates new custom importers that use the given `resourcePath` if libsass calls the custom importer with `prev`\n * being 'stdin'.\n *\n * Why do we need this? We have to use the `data` option of node-sass in order to compile our sass because\n * the `resourcePath` might not be an actual file on disk. When using the `data` option, libsass uses the string\n * 'stdin' instead of a filename.\n *\n * We have to fix this behavior in order to provide a consistent experience to the webpack user.\n *\n * @param {function|Array<function>} importer\n * @param {string} resourcePath\n * @returns {Array<function>}\n */\nfunction proxyCustomImporters(importer, resourcePath) {\n    return [].concat(importer).map((importer) => {\n        return function (url, prev, done) {\n            return importer.apply(\n                this, // eslint-disable-line no-invalid-this\n                Array.from(arguments)\n                    .map((arg, i) => i === 1 && arg === \"stdin\" ? resourcePath : arg)\n            );\n        };\n    });\n}\n\nmodule.exports = proxyCustomImporters;\n"]}